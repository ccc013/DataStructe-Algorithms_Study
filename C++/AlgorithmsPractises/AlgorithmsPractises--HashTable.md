### AlgorithmsPractises--HashTable

------

记录算法练习中的练习题以及实现的代码，练习题主要是来自[LeetCode](https://leetcode.com/problemset/algorithms/)，主要还是按照级别，由简单到难的顺序练习，并且主要是有关哈希表的算法题。

##### 1 [Single Number](https://leetcode.com/problems/single-number/)

题目描述如下：

> Given an array of integers, every element appears *twice* except for one. Find that single one.

给定一个数组，这个数组中除了一个数字只出现一次外，其余数字都出现两次，要求寻找只出现一次的数组元素。解法如下：

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        if(nums.size() <= 0)
            return 0;
        int lens = nums.size();
        int res = nums[0];
        for(int i=1; i<lens; i++){
            res ^= nums[i];
        }
        return res;
    }
};
```

上述解法使用了**异或**的方法，两个相同的数字异或会得到0，因此对数组元素依次进行异或，最终得到的结果就是只出现一次的数组元素，这个方法不需要额外的辅助空间，时间复杂度也只需要$O(n)$。

##### 2 [Single Number II](https://leetcode.com/problems/single-number-ii/)

题目描述如下：

> Given an array of integers, every element appears *three* times except for one, which appears exactly once. Find that single one.

相比第一题，这题从出现两次变成三次，不能简单使用异或了。解法如下：

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        if(nums.size() <= 0)
            return 0;
        int lens = nums.size();
        map<int, int> res;
        for(int i=0; i<lens; i++){
            if(res.find(nums[i]) != res.end()){
                res[nums[i]]++;
            }else{
                res[nums[i]] = 1;
            }
        }
        int r=0;
        for(int i=0; i<lens; i++){
            if(res[nums[i]] == 1){
                r = nums[i];
            }
        }
        return r;
    }
};
```

这是使用了哈希表，但是耗费时间比较长。

另一种解法如下：

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        vector<int> t(32);////Made a array contain 32 elements.
    	int sz = nums.size();
    	int i, j, n;
    	for (i = 0; i < sz; ++i)
    	{
    		n = nums[i];
    		for (j = 31; j >= 0; --j)
    		{
    			t[j] += n & 1;//Find the last digit.
    			n >>= 1;
    			if (!n)
    				break;
    	    }
        }
    	int res = 0;
    	for (j = 31; j >= 0; --j)
    	{
    		n = t[j] % 3;//"3" represents k times. 
    		if (n)
    			res += 1 << (31 - j);
    	}
    	return res;
    }
};
```

这是首先定义一个长度为32的`vector`，它负责存放每个数组元素对应每位的相加和，然后在第二次循环中，每位相加和都会对3进行求余，因为数组中只有一个数字只出现1次，其他都是3次，在不计算这个单独的数字外，每个位的相加和应该都是3的倍数，一旦不是3的倍数，说明该位就是这个单独数字中不为0的位，然后只要将这些位叠加就得到目标数字了。

##### 3 [Find the Difference](https://leetcode.com/problems/find-the-difference/)

题目描述如下：

> Given two strings **s** and **t** which consist of only lowercase letters.
>
> String **t** is generated by random shuffling string **s** and then add one more letter at a random position.
>
> Find the letter that was added in **t**.
>
> **Example:**
>
> ```
> Input:
> s = "abcd"
> t = "abcde"
>
> Output:
> e
>
> Explanation:
> 'e' is the letter that was added.
> ```

给定两个字符串，寻找第二个字符串中增加的字符。解法如下：

```c++
class Solution {
public:
    char findTheDifference(string s, string t) {
        char r=0;
        for(char c:s) 
            r ^=c;
        for(char c:t) 
            r ^=c;
        return r;
    }
};
```

这是使用了异或的思路。因为字符也是可以转换成整数来进行异或运算的。

##### 4 [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

题目描述如下：

> Given a non-empty array of integers, return the **k** most frequent elements.
>
> For example,
> Given `[1,1,1,2,2,3]` and k = 2, return `[1,2]`.
>
> **Note: **
>
> - You may assume *k* is always valid, 1 ≤ *k* ≤ number of unique elements.
> - Your algorithm's time complexity **must be** better than O(*n* log *n*), where *n* is the array's size.

给出一个非空数组，要求找到`k`个出现次数最多的元素。解法如下：

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
       unordered_map<int, int> m;
        for (int num : nums)
            ++m[num];
        
        vector<vector<int>> buckets(nums.size() + 1); 
        for (auto p : m)
            buckets[p.second].push_back(p.first);
        
        vector<int> ans;
        for (int i = buckets.size() - 1; i >= 0 && ans.size() < k; --i) {
            for (int num : buckets[i]) {
                ans.push_back(num);
                if (ans.size() == k)
                    break;
            }
        }
        return ans;
    }
};
```

上述解法首先是用`unordered_map`来存放数组元素，将数值作为key，而其出现次数作为value，然后新建一个`vector<vector<int> >`，即二维数组，将value作为外层的索引，而key作为内层，然后再利用一个`bucket sort`来返回要求的元素。

第二种解法如下：

```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
       unordered_map<int,int> map;
        for(int num : nums){
            map[num]++;
        }
        
        vector<int> res;
        // pair<first, second>: first is frequency,  second is number
        priority_queue<pair<int,int>> pq; 
        for(auto it = map.begin(); it != map.end(); it++){
            pq.push(make_pair(it->second, it->first));
            if(pq.size() > (int)map.size() - k){
                res.push_back(pq.top().second);
                pq.pop();
            }
        }
        return res;
    }
};
```

这种解法同样使用了`unordered_map`来存放数组元素及其出现次数，但是接着是使用`priority_queue<pair<int,int>>`结构来输出需要的元素。

##### 5 [Sort Characters By Frequency](https://leetcode.com/problems/sort-characters-by-frequency/)

题目描述如下：

> Given a string, sort it in decreasing order based on the frequency of characters.
>
> **Example 1:**
>
> ```
> Input:
> "tree"
>
> Output:
> "eert"
>
> Explanation:
> 'e' appears twice while 'r' and 't' both appear once.
> So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
>
> ```
>
> **Example 2:**
>
> ```
> Input:
> "cccaaa"
>
> Output:
> "cccaaa"
>
> Explanation:
> Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
> Note that "cacaca" is incorrect, as the same characters must be together.
>
> ```
>
> **Example 3:**
>
> ```
> Input:
> "Aabb"
>
> Output:
> "bbAa"
>
> Explanation:
> "bbaA" is also a valid answer, but "Aabb" is incorrect.
> Note that 'A' and 'a' are treated as two different characters.
>
> ```

给定一个字符串，重新排列顺序，先按照频数，然后频数相同的情况是进行降序排列。实现方法如下：

```c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char,int> map;
        for(char c : s){
            map[c]++;
        }
        string res;
        vector<string> bucket(s.size()+1, "");
        //put character into frequency bucket
        for(auto& it : map){
            int n = it.second;
            char c = it.first;
            bucket[n].append(n,c);
        }
        //form descending sorted string
        for(int i=s.size(); i>0; i--) {
            if(!bucket[i].empty())
                res.append(bucket[i]);
        }
        return res;
    }
};
```

上述解法同样是先用哈希表来统计每个字符串出现的次数，然后放到一个`vector`中，最后再进行输出。其中`bucket[n].append(n,c)`表示在第n个位置的字符串中添加`n`个字符`c`。

##### 6 [Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/)

题目描述如下：

> Given two arrays, write a function to compute their intersection.
>
> **Example:**
> Given *nums1* = `[1, 2, 2, 1]`, *nums2* = `[2, 2]`, return `[2]`.
>
> **Note:**
>
> - Each element in the result must be unique.
> - The result can be in any order.

给定两个数组，返回两者的共同元素。解法如下：

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.size() <=0 || nums2.size() <= 0)
            return vector<int>();
        vector<int> res;
        map<int, int> m1,m2;
        for(int n: nums1)
            m1[n]++;
        for(int n: nums2)
            m2[n]++;
        if(m1.size() > m2.size()){
            for(auto& m: m1){
                int num = m.first;
                if(m2.find(num) != m2.end())
                    res.push_back(num);
            }
        }else{
            for(auto& m: m2){
                int num = m.first;
                if(m1.find(num) != m1.end())
                    res.push_back(num);
            }
        }
        return res;
    }
};
```

这应该是一个最容易想到的解决方法，使用两个哈希表分别存储两个数组的元素，然后再查找。

一个更快的解法如下：

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.size() <=0 || nums2.size() <= 0)
            return vector<int>();
        unordered_set<int> m(nums1.begin(), nums1.end());
        vector<int> res;
        for (auto a : nums2)
            if (m.count(a)) {
                res.push_back(a);
                m.erase(a);
            }
        return res;
    }
};
```

使用`unordered_set`保存第一个数组的元素，然后遍历第二个数组，看是否有同时存在两个数组的数值，如果有，放入`res`中，并且删除`m`中的这个元素，保证不会重复添加同一个数值。

##### 7 [Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/)

题目描述如下：

> Given two arrays, write a function to compute their intersection.
>
> **Example:**
> Given *nums1* = `[1, 2, 2, 1]`, *nums2* = `[2, 2]`, return `[2, 2]`.
>
> **Note:**
>
> - Each element in the result should appear as many times as it shows in both arrays.
> - The result can be in any order.
>
> **Follow up:**
>
> - What if the given array is already sorted? How would you optimize your algorithm?
> - What if *nums1*'s size is small compared to *nums2*'s size? Which algorithm is better?
> - What if elements of *nums2* are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?

给定两个数组，返回两个数组重复的数字，可以包含相同的数字。解法如下：

```c++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.size() <=0 || nums2.size() <= 0)
            return vector<int>();
        unordered_map<int,int> m;
        for(int n: nums1)
            m[n]++;
        vector<int> res;
        for (auto a : nums2)
            if (m.find(a) != m.end() && m[a] > 0) {
                res.push_back(a);
                m[a]--;
            }
        return res;
    }
};
```

首先使用哈希表存放第一个数组的数值和对于频数，然后遍历第二个数组，当在哈希表中能找到第二个数组对于的元素的时候，需要哈希表上对应的数值的频数减一。

第二种解法如下：

```c++
 sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        int n1 = (int)nums1.size(), n2 = (int)nums2.size();
        int i1 = 0, i2 = 0;
        vector<int> res;
        while(i1 < n1 && i2 < n2){
            if(nums1[i1] == nums2[i2]) {
                res.push_back(nums1[i1]);
                i1++;
                i2++;
            }
            else if(nums1[i1] > nums2[i2]){
                i2++;
            }
            else{
                i1++;
            }
        }
        return res;
```

这是先对两个数组进行排序，然后再依次进行遍历两个数组，因为数组已经是排序的，所以如果第一个数组元素比第二个数组元素大，那么需要让第二个数组的指针增加，否则让第一个数组的指针相加。

##### 8 