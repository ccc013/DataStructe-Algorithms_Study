### 递归

#### 简介

**递归(Recursion)**是一种应用非常广泛的算法，在二叉树的前中后序遍历中会用到，在深度优先探索中也会使用这种算法。

一般满足下面三个条件的问题都可以采用递归来实现：

1. **一个问题的解可以分解为几个子问题的解**；
2. **这个问题和分解之后的子问题，除了数据规模不同，求解思路完全一样**；
3. **存在递归终止条件**。

#### 编写递归代码

了解什么样的问题可以采用递归，但应该如何用代码实现递归呢？

实现递归代码的关键就是**写出递推公式，找到终止条件**。

举例说明，假设有 n 个台阶，每次可以跨 1 个台阶或 2 个台阶，请问 n 个台阶有多少种走法呢？

假如 n=7，那么可以 2,2,1 这样子的走法，也可以 1,2,1,1,2 这样走上去。

这个问题根据第一步的走法就分为两类，第一类就是第一步走了 1 个台阶，第二类就是第一步走了 2 个台阶。也就是说 n 个台阶的走法可以等于走 1 步后剩余 n-1 步的走法加上先走 2 步后 n-2 个台阶的走法，用公式表示就是：

```python
f(n) = f(n-1)+f(n-2)
```

这就是递推公式了，接下来就是确定终止条件。当只有 1 个台阶的时候，就不需要递推，也就是 `f(1)=1`。不过我们需要进一步确认是否这就是终止递归条件，或者是否足够，我们需要继续用 n=2，n=3 这样比较小的数进行验证。

n=2，根据递推公式是 f(2) = f(1) + f(0)。如果终止条件是上述的 f(1)=1，那 f(2) 就没法求解了，必须给出 f(0) 的数值，但如果令 f(0)=1，即 0 个台阶有 1 种走法，就不太符合正常的逻辑思维，那么我们可以让 `f(2)=2` 作为一个终止条件，因此，递归终止条件就是 `f(1)=1, f(2)=2` ，再用 n=3,n=4 来验证一下，发现这个条件是足够且正确的。

所以我们的代码实现如下：

```python
def recursive(n):
	if n == 1:
        return 1
    if n == 2:
        return 2
    return recursive(n-1) + recursive(n-2)
```

所以，递归代码的实现关键就是**如何将大问题分解为小问题的规律，然后基于此写出递推公式和递推终止条件，然后转换为代码。**

但需要注意的是，对于递归代码，要避免去想清楚整个递归过程的这种做法，这是进入了一个思维误区。我们**只需要将递归抽象为一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递推的每个步骤**。

#### 使用递归的问题

递归的优点就是可以写出非常简洁的代码，但它也存在一些缺点。

##### 堆栈溢出

当递归求解的数据规模非常大的时候，调用层次深，需要压入非常多数据到栈，那么就会有堆栈溢出的风险；

那么如果避免堆栈溢出的风险呢？

可以通过在代码中**限制递归调用的最大深度的方式**来解决这个问题。

简单的代码例子如下，设置当递归深度为 1000 时，直接报错不再进行递归

```python
# 全局变量，表示递归的深度
depth = 0

def f(n):
    depth += 1
    if depth > 1000:
        raise Exception
    if n == 1:
        return 1
    return f(n-1) + 1
```

但这种做法并不能完全解决问题，因为**最大允许的递归深度和当前线程剩余的栈空间大小有关**，事先无法计算，如果实时计算，代码会过于复杂，影响代码的可读性。当最大深度比较小，比如10,50，就可以采用这种方法，否则这种方法就不是很实用。

##### 重复计算

以走台阶的例子为例，将递归代码进行分解的话，如下图所示：

![](https://cai-images-1257823952.cos.ap-beijing.myqcloud.com/recursive_example.png)

从图中可以看到，很多函数其实重复计算了多次，为了避免重复计算，可以采用一个数据结构来保存已经求解过的 f(k)。这里，我们可以改写上述代码：

```python
has_solved_dict = dict()
def recursive(n):
	if n == 1:
        return 1
    if n == 2:
        return 2
   	if n in has_solved_dict:
        return has_solved_dict[n]
    res = recursive(n-1) + recursive(n-2)
    has_solved_dict[n] = res
    return res
```

除了堆栈溢出、重复计算这两个问题，递归还存在其他的一些问题，比如**过多的函数调用会耗时较多，消耗额外的存储空间**等等。

#### 将递归改写为非递归代码

递归虽然表达能力强，代码非常简洁，但问题也不少，空间复杂度高、有堆栈溢出风险、存在重复计算、过多函数调用会增加耗时等问题。

因此实际开发需要根据实际情况来选择是否采用递归的方式实现。

如何将递归代码改为非递归呢，以走台阶的例子，非递归实现的代码如下所示：

```python
def recursive(n):
    if n == 1:
        return 1
    if n == 2:
        return 2
    res = 0
    # 保存的是 f(n-1)
    sol1 = 1
    # 保存的是 f(n-2)
    sol2 = 2
    for i in range(3, n+1):
        res = sol1+sol2
        sol1 = sol2
        sol2 = res
    return res
```

改写的关键就是如何将递推公式转为迭代循环的方式。











