# 数据结构知识点

标签（空格分隔）： 数据结构

---

这里记录一些比较容易忘记的数据结构方面的知识点。主要是分为线性表、栈、队列、树、图、字符串、数组等几个知识点。

----------
#### 线性表

1. 广义表(Lists，又称列表)是一种**非线性的数据结构** ，是线性表的一种推广。即广义表中放松对表元素的原子限制，容许它们具有其自身结构。它被广泛的应用于人工智能等领域的表处理语言LISP语言中。在LISP语言中，广义表是一种最基本的 数据结构 ，就连LISP 语言的程序也表示为一系列的广义表。

广义表是**n(n≥0)**个元素a1，a2，…，ai，…，an的有限序列。
其中：
①ai--或者是**原子或者是一个广义表**。
②广义表通常记作：
Ls=( a1，a2，…，ai，…，an)。
③Ls是广义表的名字，n为它的长度。
④若ai是广义表，则称它为Ls的子表。
注意：
①广义表通常用圆括号括起来，用逗号分隔其中的元素。
②为了区分原子和广义表，书写时用大写字母表示广义表，用小写字母表示原子。
③若广义表Ls非空(n≥1)，则al是LS的表头，其余元素组成的表(a1，a2，…，an)称为Ls的表尾。
④广义表是递归定义的

**表头可以为表或单元素值；表尾是指除去表头后剩下的元素组成的表（即使只剩一个元素也视为表），可以为空表**

2. 单链表中，增加一个头结点是**方便运算的实现**，其好处有：

(1) 对带头结点的链表，在表的任何结点之前插入结点或删除表中任何结点，所要做的都是修改前一结点的指针域，因为任何元素结点都有前驱结点。若链表没有头结点，则首元素结点没有前驱结点，在其前插入结点或删除该结点时操作会复杂些。 (2)对带头结点的链表，表头指针是指向头结点的非空指针，因此空表与非空表的处理是一样的。

3. 单链表的每个节点都具有唯一的前驱节点和唯一的后继节点，所以当**两个单链表存在相交的节点时，这两个链表则同时拥有这个节点，以及这个节点的所有后继节点**，当这个公共节点是尾节点时，他们则只含有公共一个节点-------尾节点。
4. **快慢指针是判断单链表是否有环的一种方法**：两个指针，每次移动的步长为2叫做快指针，每次移动步长为1的指针叫做慢指针。快慢指针同时从头结点出发，当快指针率先到达NULL的时候，则说明此单链表中不存在环，当快指针追上慢指针的时候，说明此单链表中存在环。
5. **有环的单向链表和无环的单向链表不能相交**，因为当相交的时候，无环的单向链表也会被迫存在一个环，只不过这个环的”起点“可能不是原来单向链表的头结点。
6. **两个单向链表之间相交可以存在环**。
7. 线性表的顺序存储结构是一种**随机存取的存储结构**，也就是访问时可以按下标随机访问。

----------
#### 栈

1. 解析XML时，需要校验节点是否闭合，使用栈结构比较合适。
2. 有`n`个数顺序(依次)入栈,出栈序列有`Cn`种,$Cn=\frac{1}{n+1}*\frac{(2n)!}{n! * n!}$。
3. 在快速排序中，需要使用递归来分别处理左右子段，递归深度可以理解为系统栈保存的深度,**先处理短的分段再处理长的分段，可以减少时间复杂度**

----------
#### 队列

* 队列满的条件是：**（rear+1）%QueueSize==front**；
* 队列长度公式是：**（rear-front+QueueSize）%QueueSize**。注意，**此处rear指向队尾元素的下一个位置**
* 队空条件：**rear == front**

----------
#### 树

1. 二叉树转换成森林中树的个数，与该树根节点一直往右遍历，到叶子节点的节点数相同。高度为h的完全二叉树，最右可能有**h或者h-1个节点**。
2. 几种常见的数据结构的操作性能如下图：

![此处输入图片的描述][1]

由图中可以知道，**哈希表和二叉树**具有较好的查找、插入和删除性能。

4.一个结点的子树个数就是其度；一棵树的边数=结点数-1。一棵树的度就是其结点中度的最大值。
5.**平衡树左右子树的高度差的绝对值不超过1（左右子树的高度差为该结点的平衡因子，只能取 -1， 0， 1）， 且其左右子树也是平衡树。**

向平衡树中插入结点时，该结点一定是插入在叶子节点上的，这时需要检查平衡树的各结点的平衡因子**，如果有平衡因子的绝对值大于1的结点存在，就需要调整结点使其再次满足平衡树的性质。**删除结点的时候也要检查平衡树的性质是否被破坏，然后做出相应的调整。

综上，如果删除的结点N是叶子结点且删除之后平衡树不会涉及调整，那么再次插入该结点，树是相同的，否则就不同。同理，先插入结点M，若其不改变平衡树的性质，再删除结点M，树是相同的，否则就会不同。

6. 对于二叉树的前、中、后序

* 已知先序和后序，不能唯一确定二叉树；
* 已知先序或后序，而又知中序，则能唯一确定二叉树；
* 先序、中序相同时，二叉树没有左子树；
* 后序、中序相同时，二叉树没有右子树；
* 后序、先序相同时，只有一个根节点；
* 一棵**非空的二叉树**的前序序列和后序序列正好**相反**,则该二叉树一定满足**其中只有一个叶结点**

7.最小生成树的`Kruskal`算法是一种贪心法

8.以 N 代表二叉树总节点数，n0,n1,n2 分别代表度为 0,1,2 的节点数。

​	那么可以得到：

​	N = n0 + n1 + n2;

​	N = 2*n2 + n1 + 1;(1代表根节点)

​	联立上面两个等式，可以得到二叉树中叶子节点(度为0)和度为 2 的节点的关系有：

​	n0 = n2 + 1;

9.使用**数组存储**的二叉树，是**按照层次顺序来存储**的。

10.**树与二叉树是两种不同的树型结构**，二叉树中孩子节点是有严格的左右之分的;树中结点的最大度数没有限制，但是二叉树的结点的最大度数是2.

11.**B树只支持随机搜索，B+ 树支持随机和顺序搜索。**

12.二叉树中满足**从任一结点出发到根的路径上所经过的结点序列按其关键字有序的是堆**。

13**.B+树是B-树的变体，也是一种多路搜索树，在B-树的基础上做了一些改动**。 B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。**适合做索引，对磁盘数据来说，索引查找是比较高效的。**

14.**后序线索树的遍历仍需要栈的支持。**

15.各边**权值不同**的无向连通图的**最小生成树是唯一**的。

16.    最小生成树算法是逐次取最短的路径连通未连接节点和“已连接节点集合”。

17.    **次优查找树**可以表示静态查找表。

18.    m叉树每个结点有m个指针域，总共有n个结点，则非空指针域（即分支数）= `n-1`，则空指针个数为`n*m -(n-1) = n*(m-1)+1`。

19.    已知一个序列，比如{100,6070,50,32,65}，怎么判断是不是堆？

                       答案：**把这个序列看成数组型的二叉树，如果根结点是i，左子树是2\*i，右子树是2*i+1。**。**堆分为最大堆与最小堆。**最大堆是所有父节点都比左右子树大，而最小堆则是父节点都比左右子树小。

20.    **二叉排序树的中序遍历序列一定是有序序列。**

21.    **红黑树是特殊的AVL树**，**AVL树又是特殊的二叉查找树**，它的**除删除之外所有操作平均运行时间都为$O(log(n))$**


------

##### 1）哈夫曼树(霍夫曼树）
1. 定义：给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，**称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。**哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

2. 构造方法：

假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：
(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；
(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
(3)从森林中删除选取的两棵树，并将新树加入森林；
(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

3.**路径和路径长度**

在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从**根结点到第L层结点的路径长度为L-1**。

4.结点的权及带权路径长度
若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。**结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。**

5.树的带权路径长度
树的带权路径长度规定为**所有叶子结点的带权路径长度之和**，记为WPL

6.**哈夫曼树的形状是不唯一的，但是它的带权路径长度WPL是唯一的。**

7.哈夫曼树只有**度为2和叶子结点**。因此其结点个数**不能是偶数。**

------

##### 2）B树

B树也称为**B-树**，一棵m阶B-树，或为空树，或为满足下列特性的m叉树：**(m≥3)**

1)树中每个结点**最多含有m个孩子**（m>=2）；

2)除根结点和叶子结点外，**其它每个结点**至少有**[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）**；

3)若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；

4)所有叶子结点都出现在同一层，**叶子结点不包含任何关键字信息**(叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素）。

5)每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：

       a)   Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。

       b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。

       c)   关键字的个数n必须满足： **[ceil(m / 2)-1]<= n <= m-1**。

6)每个结点能包含的关键字的个数有一个上界和下界。这些界可以称为B-树的相应结点的最小度数(内结点中结点最小孩子数目，即前面提到指针P的个数)的固定整数t>=2来表示

​	a).每个非根结点必须至少有t-1个关键字，每个非根的内结点至少有t个子女,即。如果树是非空的，则根结点至少包含一个关键字。

​	b).每个结点可包含至多2t-1个关键字，每个非根的内结点至多可有2t个子女。如果一个结点是满的，则它有2t-1个关键字.

​	c).**综上根节点关键字的个数范围: [1, 2*t - 1]，非根节点关键字的个数范围: [t-1, 2\*t - 1]**

* **m阶B-树含有n个关键字，最大深度为$log_{m/2}(\frac{n+1}{2})+2$** 。

------

##### 3）哈希表

* 哈希函数有一个共同的性质，即函数值应当以**同等概率**取其值域的每个值；
* STL_Map的内部实现是一颗红黑树，但是只是一颗在内存中建立二叉树树，**不能用于磁盘操作，而其内存查找性能也比不上Hash查找。**
* **Hash操作能根据散列值直接定位数据的存储地址**，设计良好的hash表能在常数级时间下找到需要的数据，但是**更适合于内存中的查找。**
* 构造散列函数的方法有**直接定址法、数字分析法、折叠法 、平方取中法、减去法、基数转换法 、除留余数法、随机乘数法、字符串数值哈希法、旋转法 、伪随机数法** 
* 已知某个哈希表的n个关键字具有相同的哈希值，如果使用二次探测再散列法将这n个关键字存入哈希表，至少要进行$\frac{n*(n+1)}{2}$。

----------
#### 图

1. 一个有向图能被拓扑排序的充要条件就是它是一个**有向无环图**。

2. **有向无环图的拓扑排序可以看成图的层序遍历**，每一层的顶点可以有不同的顺序，这就造成拓扑排序序列**不唯一**。

   具体实现方法如下：

   由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。

   (1) 选择一个**入度为0**的顶点并输出之；

   (2) 从网中删除此顶点及所有出边。

   循环结束后，若输出的顶点数小于网中的顶点数，则输出“有回路”信息，否则输出的顶点序列就是一种拓扑序列

3. 如果有向图的拓扑排序序列是**唯一**的时候，说明各个顶点已经排在一个线性有序的序列中，每个顶点都有**唯一的前驱后继关系**。这就说明有首有尾，**第一个顶点入度为0，最后一个顶点出度为0.**

4. **强连通分量是有向图的极大强连通子图。****有n个顶点的强连通图最多有n(n-1)条边，最少有n条边。**
   有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi>vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点 强连通 (strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个**强连通图**。**有向图的极大强连通子图，称为强连通分量 (strongly connected components)。**

5. **连通图和连通分量都是针对无向图**。

6. **用顶点表示事件，用弧表示活动，弧的权值表示活动所需要的时间，用这种方式构造的**有向无环图**叫做边表示活动的网（Activity On Edge Network），简称**AOE-网**。在AOE-网中存在**惟一的、入度为0**的顶点，叫做**源点**；存在**惟一的、出度为0**的顶点，叫做**汇点**。从源点的汇点的最长路径的长度即为完成整个工程任务所需的时间，该路径叫做关键路径。关键路径上的活动叫做关键活动。这些活动的任意一项活动未能按期完成，则整个工程的完成时间就要推迟。相反，如果能够加快关键活动的进度，则整个工程就能够提前完成。**

7. 十字链表（Orthogonal List)是有向图的另一种链式存储结构** 。该结构可以看成是将有向图的 邻接表 和逆邻接表结合起来得到的。用十字链表来存储有向图，可以达到高效的存取效果。同时，代码的可读性也会得到提升。*

8. 一个具有n个顶点的连通无向图，最多可以有$\frac{n(n-1)}{2}$条边。

9. **图的遍历是从给定的源点出发，**每一个顶点仅被访问一次**。遍历的基本算法有两种：**深度遍历DFS和广度遍历BFS**，基于递归实现，并且都**适用于有向图和无向图**。**

10. **非连通的图没有生成树**。这是由生成树的定义决定的：生成树是连通图的包含图中的所有顶点的极小连通子图。

11. 用邻接矩阵法存储图,占用的存储空间数**只与图中结点个数有关,**而与边数无关。

12. 若一个有向图具有**有序的 拓扑排序序列,**那么它的邻接矩阵必定为**三角矩阵**。

13. 用邻接表表示图时,拓扑排序算法时间复杂度为$O(n+e)$。

求各顶点入度的时间复杂度是$O(e)$，即边的个数。

建零入度顶点栈的时间复杂度是$O(n)$，即顶点的个数。

每个顶点都需要进一次栈，出一次栈，然后把入度减一。执行的总次数也是边的个数。 所以时间复杂度是$O(n+e)$。

14.    **工作最迟开始时间LSii(LatestStartTime)**——是指在不影响整个任务按期完成的前提下，本工作必须开始的最迟时刻。**工作的最迟开始时间等于工作最迟完成时间与其持续时间之差。**

 **工作最早开始时间ESii(EarliestStartTime)**——是指在其所有前面工作全部完成后，本工作有可能开始的最早时刻。

**关键路径**，AOE网中，从事件i到j的路径中，加权长度最大者称为i到j的关键路径（Critical Path）， 显然，关键路径决定着AOE网的工期，关键路径的长度就是AOE网代表的工程所需的最小工期。

 **关键活动，若活动ak的最大可利用时间等于0（即(l(k)=e(k)），则称ak 为关键活动，**否则为非关键活动。 显然，关键活动的延期，会使整个工程延期。但非关键活动不然，只要它的延期量不超过它的最大可利用时间，就不会影响整个工期。**换句话说，即关键活动一定位于关键路径上。**

15.    对有n 个顶点、 e 条边且使用**邻接表**存储的有向图进行广度优先遍历，算法的时间复杂度是$O(n+e)$；如果是使用矩阵存储，则是$O(n*e)$。

16.    一个具有n个顶点的无向图，若采用邻接表表示，则表头向量的大小为**顶点数`n`。**

17.    正如我们所知道的，Floyd算法用于求最短路径。Floyd算法可以说是Warshall算法的扩展，三个for循环就可以解决问题，所以它的时间复杂度为**O(n^3)**。

Floyd算法的基本思想如下：从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点X到B。所以，**我们假设Dis(AB)为节点A到节点B的最短路径的距离，对于每一个节点X，我们检查Dis(AX) + Dis(XB) < Dis(AB)是否成立，如果成立，证明从A到X再到B的路径比A直接到B的路径短，我们便设置Dis(AB) = Dis(AX) + Dis(XB)，**这样一来，当我们遍历完所有节点X，Dis(AB)中记录的便是A到B的最短路径的距离。

很简单吧，代码看起来可能像下面这样：

```c++
int n;//n为节点个数
 for(int i=0; i<n; ++i )
{
     for (int j=0; j<n; ++j )
     {
       for ( int k=0; k<n; ++k )
       {
         if ( Dis[i][k] + Dis[k][j] < Dis[i][j] )
         {
           // 找到更短路径
           Dis[i][j] = Dis[i][k] + Dis[k][j];
          }
        }
     }
 }
```

18.    判断 **无向图** 中是否存在回路（环）的算法描述

       如果存在回路，则必存在一个子图，是一个环路。环路中所有顶点的度>=2。
       算法：

       第一步：删除所有度<=1的顶点及相关的边，并将另外与这些边相关的其它顶点的度减一。

       第二步：将度数变为1的顶点排入队列，并从该队列中取出一个顶点重复步骤一。

       如果最后还有未删除顶点，则存在环，否则没有环。

19.    **有向图**是否有环的判定算法，主要有**深度优先和拓扑排序、求最短路径三种方法**。

20.    深度优先遍历：优先探索完一条通路后才返回**倒数第二个节点**继续探索另一条通路。如此往复直到所有节点都遍历结束

21.    求解**加权有向图**的最短路径的算法是**Ford-Bellman**算法。

----------
#### 字符串

1. KMP算法最大的特点就是**指示主串的指针不需要回溯**，因此指针不可能变小；

2. 设`S`为一个长度为`n`的字符串,其中的字符各不相同,则`S`中的互异的非平凡子串(非空且不同于`S`本身)的个数为$\frac{n(n+1)}{2}+1$。

3. next数组下标从1开始计算

   next[1] 肯定是 0 

   next[2] 肯定是 1

   next[n] 的情况，将前面n-1个字符，计算从首尾开始组成最大的相同子串的长度，如果找到，那么next值是该长度加1，否则next值是1。

   举例

   next[6]的计算，字符串第六位是** a **，( ababa** a **ababaa)

   将前面的5个字符，从头尾开始取4个组成子串比较，如果不相等，则从首尾取3个字符组成子串继续比较，并以此类推， 如果一直比较到最后一个字符都不相等，那么该next值为1。

   4个字符的情况：abab : baba

   3个字符的情况：aba   :  aba  此时相等，那么next[6] = 3+1 = 4

4. ​

----------
#### 数组

1. 使用**三元数组表示稀疏矩阵时**，每个元素需要用行号，列号和元素值表示，同时还要有三个成员来记住矩阵的行数，列数和元素总数，所以对于一个$i\times j$的稀疏矩阵，每个元素类型需要的字节数是n，非0元素的个数是m，则用三元数组表示的时候需要的总字节数是**m\*3\*n+3*n**。
2. 稀疏矩阵一般的压缩存储方法有两种：**三元组和十字链表**。

----------
#### 其他

1. 数据结构从逻辑上分为**线性结构和非线性结构**,非线性结构包括集合结构、树形结构和图形结构；存储结构形式分为**顺序存储和链式存储**。

2. C++ STL 的实现：
    1.**vector**  底层数据结构为数组 ，支持快速随机访问
    2.**list**    底层数据结构为双向链表，支持快速增删
    3.**deque**   底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问
    4.**stack**   底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
    5.**queue**   底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
    6.4和5是适配器,而不叫容器，因为是对容器的再封装
    7.**priority_queue** 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
    8.**set**       底层数据结构为红黑树，有序，不重复
    9.**multiset**  底层数据结构为红黑树，有序，可重复 
    10.**map**      ﻿﻿﻿﻿底层数据结构为红黑树，有序，不重复
    11.**multimap** 底层数据结构为红黑树，有序，可重复
    12.**hash_set** ﻿﻿﻿﻿底层数据结构为hash表，无序，不重复
    13.**hash_multiset** 底层数据结构为hash表，无序，可重复 
    14.**hash_map**      ﻿﻿﻿﻿底层数据结构为hash表，无序，不重复
    15.**hash_multimap** 底层数据结构为hash表，无序，可重复 

3. 解决**Hash冲突**的方法的描述：

   *  开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止。
   *  拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中


   (1)**拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短； **
   (2)由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况； 
   (3)开放定址法为减少冲突，要求装填因子α较小，故**当结点规模较大时会浪费很多空间**。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； 
   (4)在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 

4. 一个直线将一个平面分成 2 部分，两条直线分成 4 部分，如果直线不平行，多条直线不共一点，问 100 条直线将平面分成几部分

   解法： 

   > n代表线数，f(n)代表分成了多少部分
   >
   > n=1    f(1)=2
   >
   > n=2    f(2)=f(1)+2=4
   >
   > n=3    f(3)=f(2)+3=7
   >
   > n=4    f(4)=f(3)+4=11
   >
   > 所以
   >
   > f(100)=f(99)+100
   >
   > =100+99+98+……+3+2+2
   >
   > =5050+1
   >
   > =5051

   ​

   ​

[1]: http://7xrluf.com1.z0.glb.clouddn.com/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD.png