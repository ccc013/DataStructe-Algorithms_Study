# 章11 搜索树2--AVL树

标签（空格分隔）： 数据结构 算法

---
[TOC]

继续是《数据结构算法与应用：C++语言描述》的笔记，这是第11章搜索树的内容。

本节首先介绍的是AVL树的内容。

### 基本概念
  当确定搜索树的高度总是$O(logn)$时，能够保证每个搜索树操作所占用的时间为$O(logn)$。**高度为$O(logn)$的树称为平衡树（balanced tree）**。1962年， Adelson-Velskii 和 Landis 提出了一种现在非常流行的平衡树——**AVL树**。
  
> 定义 空二叉树是AVL树；如果T是一棵非空的二叉树，$T_L$和$T_R$分别是其左子树和右子树，那么当T满足以下条件时，T是一棵AVL树：**1）$T_L$和$T_R$是AVL树；2）$|h_L-h_R| \le 1$,$h_L$和$h_R$分别是左子树和右子树的高度。**

AVL搜索树既是二叉搜索树，也是AVL树。如果用AVL树来描述字典并希望在对数时间内完成每一种字典操作，那么，AVL树必须具备下述特征：
1） $n$个元素（节点）的AVL树的高度是$O(logn)$。
2） 对于每一个$n(n\ge 0)$值，都存在一棵AVL树。（否则，在插入完成后，一棵AVL树将不再是AVL树，因为对当前元素数来说不存在对应的AVL树）
3） 一棵$n$元素的AVL搜索树能在$O(高度)=O(logn)$的时间内完成搜索。
4） 将一个新元素插入到一棵$n$元素的AVL搜索树中，可得到$n+1$元素的AVL树，这个插入过程可以在O(logn)时间内完成。
5） 从一棵$n$元素的AVL搜索树中删除一个元素，可得到一棵$n-1$元素的AVL树，这种删除过程可以在$O(logn)$时间内完成。

特征4）包含了特征2），因此不需要明确说明特征2），而特征1、3、4和5将在以下小节中详细介绍。

### AVL树的高度
  我们可以获得一棵$n$节点的AVL树的高度的范围。假设$N_h$是一棵高度为$h$的AVL树中最小的节点数。在最坏情况下，根节点的两个左右子树中一棵子树的高度是$h-1$，另一棵子树的高度是$h-2$，而且两棵子树都是AVL树，因此有：$N_h = N_{h-1}+N_{h-2}+1,N_0=0,N_1=1$
  
  可以看到$N_h$的定义与斐波那契数列的定义非常相似：$F_n = F_{n-1}+F_{n-2},F_0=0,F_1=1$,因此也可以这样来表示：$N_h=F_{h+2}-1,h\ge 0$。如果树中有$n$个节点，那么树的最大高度是$O(logn)$。
  
### AVL树的描述
  




